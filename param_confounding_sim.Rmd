---
title: "Parametric confounding simulations"
author: "Harrison Li"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(earth)
library(splines)
library(quadprog)
```


```{r}
# Input and output directory
DIR <- "/Users/harrisonli/Documents/iCloud_Documents/Stanford/Combining_RCT_and_observational_data/"
```

```{r}
# Vectorized evaluation of RCT propensity score e
# X is assumed to be a matrix
e_fun <- function(X, overlap, alphas=NULL) {
  return(rep(0.5, nrow(X)))
}
```

# Helper functions

```{r}
# Returns a list of K indices dividing indices 1:n at random into
# K folds as equally sized as possible
get_fold_inds <- function(n, K, seed=NULL) {
  if (K == 1) {
    inds <- list()
    inds[[1]] <- 1:n
    return(inds)
  }
  set.seed(seed)
  perm <- sample(n)
  cut_ind <- cut(1:n, breaks=K, labels=FALSE)
  return(lapply(1:K, function(k) perm[which(cut_ind==k)]))
}
```

```{r}
# Adds a column of 1s to mat
add_intercept <- function(mat) {
  mat <- as.matrix(mat)
  return(cbind(rep(1, nrow(mat)), mat))
}
```

# Functions pertaining to the DGP

```{r}
# Vectorized evaluation of mean function m(S,Z,X) = E(Y|S,Z,X)
m_fun <- function(s, z, X, betas) {
  x <- rowSums(X)
  d <- ncol(X)
  return(z*(1+rowSums(X[,1:2])+rowSums(X[,1:2]^2))+rowSums(X)+
           (1-s)*(2*z-1)*(add_intercept(X) %*% betas))
}
```

```{r}
# Vectorized evaluation of variance function V(S,Z,X) = Var(Y|S,Z,X)
V_fun <- function(s, X, overlap, betas) {
  d <- ncol(X)
  return(exp((1-overlap)*(add_intercept(X) %*% betas)/2) + (1-s))
}
```

```{r}
# Vectorized evaluation of observational propensity score r
r_fun <- function(X, alphas) {
  return(as.vector(plogis(add_intercept(X) %*% alphas)))
}
```

```{r}
# Vectorized evaluation of selection probability function p
p_fun <- function(X, rho, overlap) {
  if (overlap) {
    rep(rho, nrow(X))
  } else {
    X <- as.matrix(X)
    x_rct_joint <- apply(dunif(X, min=-2, max=2), MARGIN=1, prod) * rho
    x_obs_joint <- apply(dnorm(X), MARGIN=1, prod) * (1-rho)

    return(x_rct_joint/(x_rct_joint+x_obs_joint))
  }
}
```

# Function to generate simulated data

```{r}
# Generates experimental and observational data
gen_data <- function(n_rct, n_obs, overlap, alphas, betas, seed=NULL) {
  
  ## Infer dimension of X
  d <- length(alphas) - 1
  if (length(betas) != (d+1)) {
    stop("alphas and betas must have the same length")
  }
  
  set.seed(seed)
  
  ## Generate X
  X_names <- paste("x", 1:d, sep="")
  if (overlap) {
    X_exp <- matrix(rnorm(d*n_rct), ncol=d)
  } else {
    X_exp <- matrix(runif(d*n_rct, min=-2, max=2), ncol=d)
  }
  X_obs <- matrix(rnorm(d*n_obs), ncol=d)
  df_exp <- as.data.frame(X_exp)
  df_obs <- as.data.frame(X_obs)
  colnames(df_exp) <- X_names
  colnames(df_obs) <- X_names
  
  ## Generate Z
  df_exp$z <- rbinom(n=n_rct, size=1, prob=e_fun(X_exp, overlap, alphas))
  df_obs$z <- rbinom(n=n_obs, size=1, prob=r_fun(X_obs, alphas))
  
  # Generate U
  u_obs <- rnorm(n=n_obs, 
                 mean=(2*df_obs$z-1) * (add_intercept(X_obs) %*% betas), sd=1)

  ## Generate Y
  df_exp$y <- m_fun(s=1, z=df_exp$z, X=X_exp, betas=betas) + 
    rnorm(n=n_rct, sd=exp((1-overlap)*(add_intercept(X_exp) %*% betas)/4))
  df_obs$y <- m_fun(s=1, z=df_obs$z, X=X_obs, betas=betas) + u_obs + 
    rnorm(n=n_obs, sd=exp((1-overlap)*(add_intercept(X_obs) %*% betas)/4))
  
  ## Bind into single data frame
  df <- rbind(df_exp, df_obs)
  df$s <- c(rep(1, n_rct), rep(0, n_obs))
  return(df)
}
```

# Functions to estimate nuisance functions

```{r}
# Estimates nuisance functions 
# p_hat estimates p(x) = Pr(S=1 | X=x) = E(S | X=x)
# r_hat estimates pi(x) = Pr(Z=1 | X=x,S=0) = E(Z | X=x,S=0)
# msz_hat estimates msz(x) = E(Y | X=x,S=s,Z=z) for (s, z) in {0, 1}^2
# df must include columns x, z, y, s
fit_nuisance_functions <- function(df, overlap) {
  x_names <- colnames(df)[grepl("^x", colnames(df))]
  y_form <- formula(paste("y ~", paste(x_names, collapse="+")))
  z_form <- formula(paste("z ~", paste(x_names, collapse="+")))
  s_form <- formula(paste("s ~", paste(x_names, collapse="+")))
  
  ## Set p_hat = 0 outside overlap region
  if (overlap) {
    x_mask <- rep(TRUE, nrow(df))
  } else {
    x_mask <- (apply(df[,x_names], MARGIN=1, min) >= -2) & 
              (apply(df[,x_names], MARGIN=1, max) <= 2)
  }
  
  ## Fit nuisance function models
  mean_model_11 <- earth(y_form, degree=2, data=df, subset=(df$s==1 & df$z==1))
  mean_model_10 <- earth(y_form, degree=2, data=df, subset=(df$s==1 & df$z==0))
  mean_model_01 <- earth(y_form, degree=2, data=df, subset=(df$s==0 & df$z==1))
  mean_model_00 <- earth(y_form, degree=2, data=df, subset=(df$s==0 & df$z==0))
  r_model <- suppressWarnings(earth(z_form, degree=2, data=df, 
                                     glm=list(family="binomial"),
                                     subset=(df$s==0)))
  p_model <- suppressWarnings(earth(s_form, degree=2, data=df, 
                                    glm=list(family="binomial"),
                                    subset=x_mask))
    
  ## Fit models to estimate variance function
  df$m11_hat <- predict(mean_model_11, newdata=df, type="response")
  df$m10_hat <- predict(mean_model_10, newdata=df, type="response")
  df$m01_hat <- predict(mean_model_01, newdata=df, type="response")
  df$m00_hat <- predict(mean_model_00, newdata=df, type="response")
  var_model_11 <- glm(formula(paste("I((y-m11_hat)^2+.Machine$double.eps) ~", 
                                    paste(x_names, collapse="+"))),
                      family=gaussian(link="log"), data=df, 
                      subset=(df$s==1 & df$z==1),
                      control=list(maxit=100))
  var_model_10 <- glm(formula(paste("I((y-m10_hat)^2+.Machine$double.eps) ~", 
                                    paste(x_names, collapse="+"))),
                      family=gaussian(link="log"), data=df, 
                      subset=(df$s==1 & df$z==0),
                      control=list(maxit=100))
  var_model_01 <- glm(formula(paste("I((y-m01_hat)^2+.Machine$double.eps) ~", 
                                    paste(x_names, collapse="+"))),
                      family=gaussian(link="log"), data=df, 
                      subset=(df$s==0 & df$z==1),
                      control=list(maxit=100))
  var_model_00 <- glm(formula(paste("I((y-m00_hat)^2+.Machine$double.eps) ~", 
                                    paste(x_names, collapse="+"))),
                      family=gaussian(link="log"), data=df, 
                      subset=(df$s==0 & df$z==0),
                      control=list(maxit=100))
  
  return(list(m11=mean_model_11, m10=mean_model_10, m01=mean_model_01, 
              m00=mean_model_00, pi=r_model, p=p_model,
              v11=var_model_11, v10=var_model_10, v01=var_model_01,
              v00=var_model_00))
}
```

```{r}
# Estimates theta via method of Kallus et al. (2018)
get_theta_hat <- function(df) {
  x_names <- colnames(df)[grepl("^x", colnames(df))]
  if (!all(c("m11_hat", "m10_hat", "m01_hat", "m00_hat", "r_hat", "p_hat") %in% 
           names(df))) {
    stop("df needs nuisance function prediction columns")
  }
  model <- lm(formula(paste("I(y*(z/e-(1-z)/(1-e))-m01_hat+m00_hat)", "~",
                            paste(x_names, collapse="+"))), 
              data=df, subset=(s==1))
  return(model$coefficients)
}
```

```{r}
# Add nuisance function estimates
# Estimates of [0, 1] valued functions truncated to [1/sqrt(n), 1-1/sqrt(n)]
# for n the number of observations used for fitting
add_nuisance_predictions <- function(df, model_list, 
                                     use_nonparam_m11_estimate) {
  df$m11_hat <- predict(model_list$m11, newdata=df, type="response")
  df$m10_hat <- predict(model_list$m10, newdata=df, type="response")
  df$m01_hat <- predict(model_list$m01, newdata=df, type="response")
  df$m00_hat <- predict(model_list$m00, newdata=df, type="response")
  df$r_hat <- pmax(1/sqrt(nrow(model_list[["pi"]]$bx)),
                    pmin(1-1/sqrt(nrow(model_list[["pi"]]$bx)),
                         predict(model_list$pi, newdata=df, type="response")))
  df$p_hat <- pmax(1/sqrt(nrow(model_list[["p"]]$bx)), 
                   pmin(1-1/sqrt(nrow(model_list[["p"]]$bx)),
                        predict(model_list$p, newdata=df, type="response")))
  df$v11_hat <- pmax(1/sqrt(length(model_list[["v11"]]$y)),
                     pmin(max(df$y^2),
                     predict(model_list$v11, newdata=df, type="response")))
  df$v10_hat <- pmax(1/sqrt(length(model_list[["v10"]]$y)),
                     pmin(max(df$y^2),
                     predict(model_list$v10, newdata=df, type="response")))
  df$v01_hat <- pmax(1/sqrt(length(model_list[["v01"]]$y)),
                     pmin(max(df$y^2),
                     predict(model_list$v01, newdata=df, type="response")))
  df$v00_hat <- pmax(1/sqrt(length(model_list[["v00"]]$y)),
                     pmin(max(df$y^2),
                     predict(model_list$v00, newdata=df, type="response")))
  
  ## Set p_hat = 0 outside overlap region
  x_names <- colnames(df)[grep("^x", colnames(df))]
  if (overlap) {
    x_mask <- rep(TRUE, nrow(df))
  } else {
    x_mask <- (apply(df[,x_names], MARGIN=1, min) >= -2) & 
              (apply(df[,x_names], MARGIN=1, max) <= 2)
  }
  df$p_hat[!x_mask] <- 0
  
  ## Use theta_hat to estimate m11 from estimates of m10, m01, m00 if
  ## use_nonparam_m11_estimate=FALSE
  if (!use_nonparam_m11_estimate) {
    theta_hat <- get_theta_hat(df)
    df$m11_hat <- with(df, m10_hat+m01_hat-m00_hat) + 
      add_intercept(df[,x_names]) %*% theta_hat
  }
  return(df)
}
```

```{r}
# Adds true nuisance function evaluations to df (for oracle estimators)
add_true_nuisance_functions <- function(df, overlap, alphas, betas) {
  X <- as.matrix(df[,grep("^x", colnames(df))])
  d <- ncol(X)
  rho <- mean(df$s)
  df$m11_hat <- m_fun(s=1, z=1, X=X, betas=betas)
  df$m10_hat <- m_fun(s=1, z=0, X=X, betas=betas)
  df$m01_hat <- m_fun(s=0, z=1, X=X, betas=betas)
  df$m00_hat <- m_fun(s=0, z=0, X=X, betas=betas)
  df$p_hat <- p_fun(X, rho, overlap)
  df$r_hat <- r_fun(X, alphas)
  df$v11_hat <- V_fun(s=1, X=X, overlap=overlap, betas=betas)
  df$v10_hat <- V_fun(s=1, X=X, overlap=overlap, betas=betas)
  df$v01_hat <- V_fun(s=0, X=X, overlap=overlap, betas=betas)
  df$v00_hat <- V_fun(s=0, X=X, overlap=overlap, betas=betas)
  return(df)  
}
```

# Functions for computing estimators

```{r}
# Computes baseline estimators with sample splitting
# Baseline estimators are efficient in the absence of structural assumptions
compute_baseline_estimators <- function(df) {
  if (!all(c("m11_hat", "m10_hat", "m01_hat", "m00_hat", "p_hat", "r_hat")
    %in% names(df))) {
    stop("df does not have necessary columns containing nuisance estimates")
  }
  rho_hat <- mean(df$s)
  
  ## rct
  reg <- with(df, mean(s*(m11_hat-m10_hat))) / rho_hat
  adj <- with(df, mean(s*(z*(y-m11_hat)/e - (1-z)*(y-m10_hat)/(1-e)))) / rho_hat
  tau_hat_rct <- reg+adj
  
  ## obs
  exp_term <- with(df, mean(ifelse(s==1, (1-p_hat)/p_hat*(z*(y-m11_hat)/e - (1-z)*(y-m10_hat)/(1-e)), 0)))
  obs_term <- with(df, mean((1-s)*(m11_hat-m10_hat)))
  tau_hat_obs <- (exp_term+obs_term)/(1-rho_hat)
  
  ## tgt
  reg <- with(df, mean(m11_hat-m10_hat))
  adj <- with(df, mean(ifelse(s==1, s*(z*(y-m11_hat)/e - (1-z)*(y-m10_hat)/(1-e))/p_hat, 0)))
  tau_hat_tgt <- reg+adj
  
  return(list(rct=tau_hat_rct, obs=tau_hat_obs, tgt=tau_hat_tgt))
}
```

```{r}
# Function to fit and add columns with K-fold cross-fit nuisance estimates to df
# If use_nonparam_m11_estimate is TRUE, uses nonparametric estimate of m_11(x)
# for baseline estimator
# Otherwise learn m_11 via parametric adjustment to the estimates of
# m_10, m_01, m_00
add_nuisance_estimates <- function(df, K, use_nonparam_m11_estimate, overlap, 
                                   seed=NULL) {
  ## Split df into folds
  N <- nrow(df)
  if (K > 1) {
    fold_inds <- get_fold_inds(N, K, seed=seed)
    df_split <- lapply(fold_inds, function(inds) df[inds,])
    out_of_fold_dfs <- lapply(1:K, function(k) df[do.call("c", fold_inds[-k]),])
  } else {
    fold_inds <- list(1:N)
    df_split <- list(df)
    out_of_fold_dfs <- list(df)
  }
  
  ## Learn out-of-fold nuisance estimates
  nuisance_estimates <- lapply(out_of_fold_dfs, fit_nuisance_functions, overlap)
  
  ## Apply nuisance estimates to in-fold data, and combine into single df
  df_aug <- do.call("rbind",
                    lapply(1:K, function(k) {
                             add_nuisance_predictions(df=df_split[[k]],
                             model_list=nuisance_estimates[[k]],
                             use_nonparam_m11_estimate=use_nonparam_m11_estimate)
                     }))
  
  return(df_aug)
}
```

```{r}
# Compute efficient estimators
compute_eff_estimators <- function(df, theta_hat) {
  
  ## Compute baseline estimator
  tau_hat <- compute_baseline_estimators(df)
  rho_hat <- mean(df$s)
  N <- nrow(df)
  
  ## Ensure m11_hat-m10_hat is parametric adjustment of m01_hat-m00_hat
  ## to ensure convergence guarantee of efficient estimator
  x_names <- colnames(df)[grepl("^x", colnames(df))]
  df$m11_hat <- with(df, m10_hat+m01_hat-m00_hat) + 
    add_intercept(df[,x_names]) %*% theta_hat

  ## Learn out-of-fold best influence function estimates via regression
  Sig <- as.vector(with(df, v11_hat+v10_hat*e/(1-e)+
                          v01_hat*p_hat*e/((1-p_hat)*r_hat)+
                          v00_hat*p_hat*e/((1-p_hat)*(1-r_hat))))
  X <- df[,grep("^x", colnames(df))]
  psi_mat <- add_intercept(X)
  gepsf1_rct <- as.vector(with(df, 
                               (p_hat>0)*(v11_hat/e+v10_hat/(1-e))) / rho_hat)
  gepsf1_obs <- as.vector(with(df, 
                               ifelse(p_hat>0, (1-p_hat)/p_hat, 0) *
                                 (v11_hat/e+v10_hat/(1-e))) / (1-rho_hat))
  gepsf1_tgt <- as.vector(with(df, ifelse(p_hat>0, 
                                          (v11_hat/e+v10_hat/(1-e))/p_hat, 0)))
  lam_rct <- -1 * solve(t(psi_mat) %*% (psi_mat*(df$p_hat*df$e/Sig)) / N) %*% 
    colMeans((gepsf1_rct*df$p_hat*df$e/Sig)*psi_mat)
  lam_obs <- -1 * solve(t(psi_mat) %*% (psi_mat*(df$p_hat*df$e/Sig)) / N) %*% 
    colMeans((gepsf1_obs*df$p_hat*df$e/Sig)*psi_mat)
  lam_tgt <- -1 * solve(t(psi_mat) %*% (psi_mat*(df$p_hat*df$e/Sig)) / N) %*% 
    colMeans((gepsf1_tgt*df$p_hat*df$e/Sig)*psi_mat)  
  df$h_hat_rct <- (gepsf1_rct + as.vector((psi_mat %*% lam_rct))) / Sig
  df$h_hat_obs <- (gepsf1_obs + as.vector((psi_mat %*% lam_obs))) / Sig
  df$h_hat_tgt <- (gepsf1_tgt + as.vector((psi_mat %*% lam_tgt))) / Sig
  
  return(list(rct=tau_hat[["rct"]] - 
                mean(with(df,
                   as.vector(s*z*(y-m11_hat)-s*(1-z)*e/(1-e)*(y-m10_hat)-
                             (1-s)*z*(y-m01_hat)*p_hat*e/((1-p_hat)*r_hat) +
                             (1-s)*(1-z)*(y-m00_hat)*p_hat*e/((1-p_hat)*(1-r_hat)))*h_hat_rct)),
              obs=tau_hat[["obs"]] - 
                mean(with(df,
                   as.vector(s*z*(y-m11_hat)-s*(1-z)*e/(1-e)*(y-m10_hat)-
                             (1-s)*z*(y-m01_hat)*p_hat*e/((1-p_hat)*r_hat) +
                             (1-s)*(1-z)*(y-m00_hat)*p_hat*e/((1-p_hat)*(1-r_hat)))*h_hat_obs)),
              tgt=tau_hat[["tgt"]] - 
                mean(with(df,
                   as.vector(s*z*(y-m11_hat)-s*(1-z)*e/(1-e)*(y-m10_hat)-
                             (1-s)*z*(y-m01_hat)*p_hat*e/((1-p_hat)*r_hat) +
                             (1-s)*(1-z)*(y-m00_hat)*p_hat*e/((1-p_hat)*(1-r_hat)))*h_hat_tgt))))
}
```

# Main simulation functions

```{r}
# Run single simulation
run_single_sim <- function(n_rct, n_obs, overlap, alphas, betas, K, seed=NULL) {
  
  ## Set seed
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  ## Generate data
  df <- gen_data(n_rct=n_rct, n_obs=n_obs, overlap=overlap, alphas=alphas,
                 betas=betas, seed=seed)
  df$e <- e_fun(as.matrix(df[,grep("^x", colnames(df))]), overlap, alphas)

  ## Oracle version of nonparametric baseline
  N <- nrow(df)
  df_oracle <- add_true_nuisance_functions(df=df, overlap=overlap,
                                           alphas=alphas, betas=betas)
  
  ## Add nuisance estimates
  df_aug <- add_nuisance_estimates(df=df, K=K,
                                   use_nonparam_m11_estimate=overlap,
                                   overlap=overlap, seed=seed)
  
  ## Baseline estimators
  tau_hats_baseline <- compute_baseline_estimators(df_aug)
  tau_hats_baseline_oracle <- compute_baseline_estimators(df_oracle)
  
  ## Efficient estimators
  theta_hat <- get_theta_hat(df_aug)
  true_theta <- -2 * betas
  tau_hats_eff <- compute_eff_estimators(df=df_aug, theta_hat)
  tau_hats_eff_oracle <- compute_eff_estimators(df=df_oracle, true_theta)
  
  return(list(rct=c(baseline=tau_hats_baseline$rct, 
                    baseline_oracle=tau_hats_baseline_oracle$rct,
                    eff=tau_hats_eff$rct, eff_oracle=tau_hats_eff_oracle$rct),
              obs=c(baseline=tau_hats_baseline$obs, 
                    baseline_oracle=tau_hats_baseline_oracle$obs,
                    eff=tau_hats_eff$obs, eff_oracle=tau_hats_eff_oracle$obs),
              tgt=c(baseline=tau_hats_baseline$tgt, 
                    baseline_oracle=tau_hats_baseline_oracle$tgt,
                    eff=tau_hats_eff$tgt, eff_oracle=tau_hats_eff_oracle$tgt)))
}
```

```{r}
run_sims <- function(n_sim, n_rct, n_obs, overlap, alphas, betas, K, 
                     init_seed=NULL) {
  seed <- init_seed
  rct_estimators <- data.frame(matrix(nrow=n_sim, ncol=4))
  obs_estimators <- data.frame(matrix(nrow=n_sim, ncol=4))
  tgt_estimators <- data.frame(matrix(nrow=n_sim, ncol=4))
  for (sim in 1:n_sim) {
    if (sim %% 10 == 0) {
      print(paste("Running simulation", sim, "of", n_sim))
    }
    sim_out <- run_single_sim(n_rct=n_rct, n_obs=n_obs, overlap=overlap, 
                              alphas=alphas, betas=betas, K=K,
                              seed=seed)
    rct_estimators[sim,] <- sim_out$rct
    obs_estimators[sim,] <- sim_out$obs
    tgt_estimators[sim,] <- sim_out$tgt
    if (!is.null(seed)) {
      seed <- seed + 1
    }
  }
  colnames(rct_estimators) <- names(sim_out$rct)
  colnames(obs_estimators) <- names(sim_out$obs)
  colnames(tgt_estimators) <- names(sim_out$tgt)
  return(list(rct_estimators=rct_estimators, obs_estimators=obs_estimators, 
              tgt_estimators=tgt_estimators, n_rct=n_rct, n_obs=n_obs,
              overlap=overlap, alphas=alphas, betas=betas, K=K, 
              init_seed=init_seed))
}
```

# Run overlapped simulations

```{r}
# n_sim <- 1000
# alphas <- c(0, rep(-1, 5))
# betas <- c(0, rep(1, 5))
# K <- 5
# n_rct_list <- c(300, 600, 1000, 2500)
# overlap <- TRUE
# n_obs <- 5000
```

```{r}
# n_rct_sizes <- length(n_rct_list)
# sims_out_overlap <- vector("list", length=n_rct_sizes)
# for (i in 1:n_rct_sizes) {
#   n_rct <- n_rct_list[i]
#   print(paste("n_rct =", n_rct))
#   sims_out_overlap[[i]] <- run_sims(n_sim=n_sim, n_rct=n_rct, n_obs=n_obs,
#                                     overlap=overlap, alphas=alphas, betas=betas,
#                                     K=K, init_seed=1)
# }
```

```{r}
# Save simulation results
# saveRDS(object=sims_out_overlap, file=paste(DIR, "param_confounding_overlap", sep=""))
```

## Run non-overlapped simulations

```{r}
# n_sim <- 1000
# alphas <- c(0, rep(-1, 5))
# betas <- c(0, rep(1, 5))
# K <- 5
# n_rct_list <- c(300, 600, 1000, 2500)
# overlap <- FALSE
# n_obs <- 5000
```

```{r}
# n_rct_sizes <- length(n_rct_list)
# sims_out_no_overlap <- vector("list", length=n_rct_sizes)
# for (i in 1:n_rct_sizes) {
#   n_rct <- n_rct_list[i]
#   print(paste("n_rct =", n_rct))
#   sims_out_no_overlap[[i]] <- run_sims(n_sim=n_sim, n_rct=n_rct, n_obs=n_obs,
#                                        overlap=overlap, alphas=alphas,
#                                        betas=betas, K=K, init_seed=1)
# }
```

```{r}
## Save simulation results
# saveRDS(object=sims_out_no_overlap, file=paste(DIR, "param_confounding_no_overlap", sep=""))
```

# Print and plot results

```{r}
sims_out_overlap <- readRDS(paste(DIR, "param_confounding_overlap", sep=""))
sims_out_no_overlap <- readRDS(paste(DIR, "param_confounding_no_overlap", sep=""))
```

```{r}
# True value of estimands
get_estimands <- function(overlap, rho) {
  q <- 2
  if (overlap) {
    return(list(rct=1+q, obs=1+q, tgt=1+q))
  } else {
    return(list(rct=1+4*q/3, obs=1+q, tgt=1+(rho*4*q/3 + (1-rho)*q)))
  }
}
```

```{r}
# Bootstrap CI's of relative efficiencies
# Assumes first column of estimators is the baseline
rel_eff_boot <- function(estimators, tau, boot_seed, alpha=0.05, B=10000) {
  n <- nrow(estimators)
  bias_sq_raw <- (colMeans(estimators) - tau)^2
  var_raw <- apply(estimators, MARGIN=2, var)
  mse_raw <- bias_sq_raw + var_raw
  bias_sq_star <- bias_sq_raw[1] / bias_sq_raw[-1]
  var_star <- var_raw[1] / var_raw[-1]
  mse_star <- mse_raw[1] / mse_raw[-1]
  bias_sq_boot <- matrix(NA, B, ncol=ncol(estimators)-1)
  var_boot <- matrix(NA, B, ncol=ncol(estimators)-1)
  mse_boot <- matrix(NA, B, ncol=ncol(estimators)-1)
  set.seed(boot_seed)
  for (b in 1:B) {
    boot_est <- estimators[sample(n, n, replace=TRUE),]
    bias_sq_list <- (colMeans(boot_est) - tau)^2
    var_list <- apply(boot_est, MARGIN=2, var)
    mse_list <- bias_sq_list + var_list
    bias_sq_boot[b,] <- bias_sq_list[1] / bias_sq_list[-1]
    var_boot[b,] <- var_list[1] / var_list[-1]
    mse_boot[b,] <- mse_list[1] / mse_list[-1]
  }
  names(bias_sq_star) <- names(estimators)[-1]
  names(var_star) <- names(estimators)[-1]
  names(mse_star) <- names(estimators)[-1]
  return(list(bias_sq=rbind(bias_sq_star,
                            2*bias_sq_star - 
                              apply(bias_sq_boot, 2, quantile, 1-alpha/2),
                            2*bias_sq_star -
                              apply(bias_sq_boot, 2, quantile, alpha/2)),
              var=rbind(var_star,
                        2*var_star - apply(var_boot, 2, quantile, 1-alpha/2),
                        2*var_star - apply(var_boot, 2, quantile, alpha/2)),
              mse=rbind(mse_star,
                        2*mse_star - apply(mse_boot, 2, quantile, 1-alpha/2),
                        2*mse_star - apply(mse_boot, 2, quantile, alpha/2))))
}
```

```{r}
# Plot relative efficiencies
plot_sims <- function(sim_out_list, estimand, titles=TRUE, xaxl=TRUE) {
  all_names <- c("baseline", "baseline_oracle", "eff", "eff_oracle")
  plot_names <- c("ba", "ba_O", "eff", "eff_O")
  
  n_sims <- length(sim_out_list)
  bias_sq_est <- vector("list", length=n_sims)
  var_est <- vector("list", length=n_sims)
  mse_est <- vector("list", length=n_sims)
  boot_out <- vector("list", length=n_sims)
  boot_out_oracle <- vector("list", length=n_sims)
  n_rct_list <- rep(NA, n_sims)
  for (sim in 1:n_sims) {
    sim_out <- sim_out_list[[sim]]
    N <- sim_out$n_rct + sim_out$n_obs
    rho <- sim_out$n_rct / N
    n_rct_list[sim] <- sim_out$n_rct
    estimators <- sim_out[[paste(estimand, "estimators", sep="_")]][,all_names]
    tau <- get_estimands(overlap=sim_out$overlap, rho=rho)[[estimand]]
    boot_out[[sim]] <- rel_eff_boot(estimators=estimators[,-grep("_oracle", all_names, fixed=TRUE)], 
                                    tau=tau, boot_seed=2024)
    boot_out_oracle[[sim]] <- rel_eff_boot(estimators=estimators[,grep("_oracle", all_names, fixed=TRUE)], 
                                           tau=tau, boot_seed=2024)
    bias_sq_est[[sim]] <- (colMeans(estimators) - tau)^2
    var_est[[sim]] <- apply(estimators, MARGIN=2, var)
    mse_est[[sim]] <- bias_sq_est[[sim]] + var_est[[sim]]
  }
  
  ## Compute results
  bias_sq_df <- as.data.frame(do.call("rbind", bias_sq_est), n_rct=n_rct_list)
  var_df <- as.data.frame(do.call("rbind", var_est))
  mse_df <- as.data.frame(do.call("rbind", mse_est))
  colnames(bias_sq_df) <- plot_names
  colnames(var_df) <- plot_names
  colnames(mse_df) <- plot_names
  
  ## Plot MSE, variance, and squared bias
  par(mfrow=c(1,3))
  colors <- c("black", "black", "orange", "orange")
  linetypes <- c("solid", "dashed", "solid", "dashed")
  linewidths <- c(2, 1, 2, 1)
  max_y <- 1.1 * max(mse_df)
  plot(n_rct_list, mse_df[,1], xlab=ifelse(xaxl, "RCT size", ""), ylab="", type="b", 
       main=ifelse(titles, "MSE", ""),
       col="black", lty="solid", lwd=2, ylim=c(0, max_y))
  for (i in 2:length(all_names)) {
    lines(n_rct_list, mse_df[,i], col=colors[i], type="b", lwd=linewidths[i],
          lty=linetypes[i])
  }
  plot(n_rct_list, var_df[,1], xlab=ifelse(xaxl, "RCT size", ""), ylab="", type="b", 
       main=ifelse(titles, "Variance", ""),
       col="black", lty="solid", lwd=2, ylim=c(0, max_y))
  for (i in 2:length(all_names)) {
    lines(n_rct_list, var_df[,i], col=colors[i], type="b", lwd=linewidths[i],
          lty=linetypes[i])
  }
  plot(n_rct_list, bias_sq_df[,1], xlab=ifelse(xaxl, "RCT size", ""), ylab="", type="b", 
       main=ifelse(titles, "Squared bias", ""),
       col="black", lty="solid", lwd=2, ylim=c(0, max_y))
  for (i in 2:length(all_names)) {
    lines(n_rct_list, bias_sq_df[,i], col=colors[i], type="b", lwd=linewidths[i],
          lty=linetypes[i])
  }
  legend(x="topright", legend=plot_names, col=colors, lty=linetypes)
  
  ## Print relative efficiencies
  point_ests <- t(sapply(boot_out, function(x) x$mse[1,]))
  lowers <- t(sapply(boot_out, function(x) x$mse[2,]))
  uppers <- t(sapply(boot_out, function(x) x$mse[3,]))
  point_ests_oracle <- t(sapply(boot_out_oracle, function(x) x$mse[1,]))
  lowers_oracle <- t(sapply(boot_out_oracle, function(x) x$mse[2,]))
  uppers_oracle <- t(sapply(boot_out_oracle, function(x) x$mse[3,]))
  
  print("Relative efficiencies [95% CI]:")
  print(round(point_ests, 2))
  print(round(lowers, 2))
  print(round(uppers, 2))
  
  print("Oracle relative efficiencies [95% CI]:")
  print(round(point_ests_oracle, 2))
  print(round(lowers_oracle, 2))
  print(round(uppers_oracle, 2))
}
```

```{r}
png(paste(DIR, "param_confounding_overlap_rct.png", sep=""), width=6, height=3,
    units="in", res=300)
plot_sims(sims_out_overlap, estimand="rct", titles=TRUE, xaxl=FALSE)
```


```{r}
png(paste(DIR, "param_confounding_overlap_obs.png", sep=""), width=6, height=3,
    units="in", res=300)
plot_sims(sims_out_overlap, estimand="obs", titles=TRUE, xaxl=FALSE)
```


```{r}
png(paste(DIR, "param_confounding_overlap_tgt.png", sep=""), width=6, height=3,
    units="in", res=300)
plot_sims(sims_out_overlap, estimand="tgt", titles=TRUE, xaxl=FALSE)
```

```{r}
png(paste(DIR, "param_confounding_no_overlap_rct.png", sep=""), width=6,
    height=3, units="in", res=300)
plot_sims(sims_out_no_overlap, estimand="rct", titles=TRUE, xaxl=FALSE)
```

```{r}
png(paste(DIR, "param_confounding_no_overlap_obs.png", sep=""), width=6,
    height=3, units="in", res=300)
plot_sims(sims_out_no_overlap, estimand="obs", titles=FALSE, xaxl=FALSE)
```

```{r}
png(paste(DIR, "param_confounding_no_overlap_tgt.png", sep=""), width=6,
    height=3, units="in", res=300)
plot_sims(sims_out_no_overlap, estimand="tgt", titles=FALSE, xaxl=TRUE)
```



